#!/bin/bash
#
# Copyright (c) 2025 Michael Hanselmann. All rights reserved. Released under
# the BSD-3-Clause license.
#

set -e -u -o pipefail

usage() {
  echo "Usage: $0 [options] <unit.service> [<command...>]"
  echo
  echo 'Run a command in the same environment as a systemd service unit.'
  echo
  echo 'Options:'
  echo '  -u  Talk to the service manager of the calling user, rather than the'
  echo '      service manager of the system.'
}

opt_user=

while getopts 'hu' opt; do
  case "$opt" in
    h)
      usage
      exit 0
      ;;
    u)
      opt_user=true
      ;;
    *)
      usage >&2
      exit 1
      ;;
  esac
done

shift $((OPTIND - 1))

if (( $# < 1 )); then
  usage >&2
  exit 1
fi

ctl() {
  /usr/bin/systemctl ${opt_user:+--user} "$@"
}

unit="${1:?}"
shift

ephemeral_service=
ephemeral_socket=
fragment_paths=()
tmpdir=$(mktemp -d)

cleanup() {
  local i

  for i in "$ephemeral_socket" "$ephemeral_service"; do
    if [[ -n "$i" ]]; then
      ctl revert "$i" || :
      ctl stop "$i" || :
    fi
  done

  for i in "${fragment_paths[@]}"; do
    if [[ -e "$i" ]]; then
      rm -f "$i"
    fi
  done

  rm -rf "$tmpdir"
}

trap cleanup EXIT

ctl cat --no-pager "$unit" > "${tmpdir}/service.original"

make_name() {
  local unit_type="$1"
  local unit_raw
  local instance_name=
  local base
  local suffix

  base="$ephemeral_name_base"

  suffix=$(systemd-escape --unescape -- "$unit")
  suffix="${suffix%%@*}"
  suffix="${suffix%%.service}"
  suffix="${suffix//[^-_.a-zA-Z0-9]/_}"

  if [[ -n "$suffix" ]]; then
    base+="_${suffix::32}"
  fi

  if [[ "$unit" = *@* ]] && instance_name=$(systemd-escape --unescape --instance -- "$unit"); then
    systemd-escape --template="${base}@.${unit_type}" -- "$instance_name"
  else
    systemd-escape "${base}.${unit_type}"
  fi
}

ephemeral_name_base="unitshell_$(date +%Y%m%d_%H%M%S)_$$"
ephemeral_service=$(make_name service)
ephemeral_socket=$(make_name socket)

unit_dir=$(
  if [[ -n "$opt_user" ]]; then
    /usr/bin/systemd-path user-runtime
  else
    /usr/bin/systemd-path system-runtime
  fi
)

{
  cat "${tmpdir}/service.original"
  echo
  cat <<EOF
[Unit]
Description=Ephemeral shell for ${unit@Q}.
RefuseManualStart=no
RefuseManualStop=no
CollectMode=inactive-or-failed

[Service]
Type=exec
ExecCondition=
ExecStartPre=
ExecStartPost=
ExecStart=
ExecStart=:${tmpdir}/server
ExecReload=
ExecStop=
ExecStopPost=
Restart=no
RemainAfterExit=no
WorkingDirectory=/
BindReadOnlyPaths=${tmpdir}
ExecPaths=${tmpdir}
StandardInput=socket
StandardOutput=journal
StandardError=journal
SyslogIdentifier=${ephemeral_service%%.service}
EOF
} > "${tmpdir}/service"

{
  uid=$(id -u)
  gid=$(id -g)
  cat <<EOF
[Unit]
Description=Socket for ${ephemeral_service@Q}.

[Socket]
ListenStream=${tmpdir}/server.sock
SocketUser=${uid:?}
SocketGroup=${gid:?}
SocketMode=0600
Accept=no
EOF
} > "${tmpdir}/socket"

cat >"${tmpdir}/server" <<EOF
#!${BASH:?}

set -e

exec {UNITSHELL_LOG_FD}>&2

export UNITSHELL_LOG_FD

exec /usr/bin/s6-ipcserverd /usr/bin/s6-sudod ${tmpdir@Q}/handler
EOF

cat >"${tmpdir}/handler" <<EOF
#!${BASH:?}

set -e

wd=${PWD@Q}
cmd="\${*@Q}"

{
  echo "Command: \${cmd}"
  echo "Working directory: \${wd}"
} >&\${UNITSHELL_LOG_FD}

cd "\${wd}" || :

if test -t 0; then
  # script(1) acts as a pty-to-pty proxy. The container is unlikely to have
  # ownership of the caller's terminal and thus can't make it the controlling
  # terminal.
  SHELL=/bin/sh \
  exec /usr/bin/script --quiet --return --command "\${cmd}" /dev/null
fi

exec /bin/sh -c "\${cmd}"
EOF

chmod 0755 "${tmpdir}"
chmod 0755 "${tmpdir}/server" "${tmpdir}/handler"

write_unit() {
  local name="$1" source="$2"
  local unit_file

  unit_file="${unit_dir}/systemd/transient/${name}"

  fragment_paths+=( "$unit_file" )

  cp --no-clobber --preserve=mode "$source" "$unit_file"
}

write_unit "$ephemeral_service" "${tmpdir}/service"
write_unit "$ephemeral_socket" "${tmpdir}/socket"

ctl daemon-reload

ctl restart "$ephemeral_socket"

cmd=( "$@" )

if (( ${#cmd[*]} == 0 )); then
  cmd+=( /bin/sh )
fi

/usr/bin/s6-sudo -e "${tmpdir}/server.sock" "${cmd[@]}"

exit 0

# vim: set sw=2 sts=2 et :
